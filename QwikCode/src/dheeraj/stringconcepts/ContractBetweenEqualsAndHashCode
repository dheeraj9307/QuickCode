/*
##In case of NonString: 
== equal operator and .equals() method both compare the references but if i want 
.equals() method compare contents then i have to override the equals() method. And also 
override hashCode() to maintain the equalsâ€“hashCode contract, 
otherwise objects that are "equal" may not behave correctly in hash-based collections like:
HashSet, HashMap, Hashtable, LinkedHashSet, LinkedHashMap etc. 
If I override equals(), I must override hashCode() to follow the contract.
The contract says:
    1. If two objects are equal (equals() â†’ true), then their hashCode() must be same.
ðŸ‘‰ emp1.equals(emp2) â†’ true
ðŸ‘‰ so emp1.hashCode() == emp2.hashCode() â†’ must also be true.
    2. If two objects are not equal, their hashCodes may or may not be different (collisions allowed).
What does collisions allowed mean?
A hash collision happens when two different objects produce the same hashCode.
String s1 = "FB";
String s2 = "Ea";

System.out.println(s1.hashCode()); // 2236
System.out.println(s2.hashCode()); // 2236
System.out.println(s1.equals(s2)); // false
Here:
    â€¢ s1.equals(s2) â†’ false (different content).
    â€¢ But s1.hashCode() == s2.hashCode() â†’ SAME hash â†’ collision.

Note:
If I donâ€™t override hashCode() while overriding equals(), It will break the contract between equals() and hashCode(). 
Otherwise, logically equal objects may behave like duplicates(Set,Map) in memory-based collections. 
Note:
ArrayList, LinkedList, Vector â†’ they check duplicates or equality using only .equals().
TreeSet, TreeMap â†’ they donâ€™t use hashCode(), instead they use natural ordering (Comparable) or a Comparator. so in these, even if hashCode() is not overridden, your program still works fine hashCode() not required â†’ ArrayList, LinkedList, Vector, TreeSet, TreeMap. 
##In case of String: 
== equal operator compare the references and .equals() method compare the contents.
Note:
It Works, but not safe if someone passes null or a different class.so for that i have to add it.
@Override
public boolean equals(Object obj) {
    if (this == obj) return true;                   // same reference
    if (obj == null || getClass() != obj.getClass()) return false;
    Employee e1 = (Employee) obj;
    return this.name.equals(e1.name);
}
If i not use, then This can throw a ClassCastException if someone passes a null or a different class.
Note:
What is ClassCastException?
It happens when you try to cast an object to the wrong type at runtime.
Example:
Animal a = new Cat();
Dog d = (Dog) a;   //runtime error
Output:
Exception in thread "main" java.lang.ClassCastException: Cat cannot be cast to Dog
Reason: a actually refers to a Cat, not a Dog. 
 */